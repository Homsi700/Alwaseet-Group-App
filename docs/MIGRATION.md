# خطة إعادة هيكلة مسارات المبيعات والفواتير

## المشكلة

تم تحديد تداخل وتكرار في مسارات `invoices` و `sales` في التطبيق. كلاهما يتعامل مع المبيعات، ولكن بطرق مختلفة وهياكل بيانات مختلفة، مما يؤدي إلى:

1. صعوبة في الصيانة والتطوير
2. تكرار في الكود والوظائف
3. عدم اتساق في هيكل البيانات
4. أخطاء محتملة بسبب عدم وضوح المسؤوليات

## الحل المقترح

إعادة هيكلة مسارات التطبيق بناءً على "الموارد" (Resources) مع فصل واضح للمسؤوليات، والاستفادة القصوى من هيكل المسارات الجديد في Next.js (App Router).

## هيكل المسارات المقترح

```
app/
├── (dashboard)/            # مجموعة مسارات (Route Group) للمحتوى الخاص باللوحة الرئيسية
│   ├── layout.tsx
│   ├── page.tsx            # لوحة تحكم رئيسية
│   └── sales/              # التعامل مع عمليات المبيعات الرئيسية/التقارير
│       ├── page.tsx        # نظرة عامة على المبيعات، تقارير
│       ├── customers/      # إدارة العملاء (GET, POST, PUT, DELETE)
│       │   ├── page.tsx    # قائمة العملاء (GET)
│       │   ├── [customerId]/ # تفاصيل عميل محدد
│       │   │   ├── page.tsx  # عرض تفاصيل العميل (GET)
│       │   │   └── route.ts  # API لعميل محدد (GET, PUT, DELETE)
│       │   └── route.ts    # API للعملاء (GET, POST)
│       ├── products/       # إدارة المنتجات
│       │   ├── page.tsx
│       │   ├── [productId]/
│       │   │   ├── page.tsx
│       │   │   └── route.ts
│       │   └── route.ts
│       ├── invoices/       # إدارة الفواتير
│       │   ├── page.tsx    # قائمة الفواتير (GET)
│       │   ├── create/     # إنشاء فاتورة جديدة
│       │   │   ├── page.tsx  # صفحة إنشاء الفاتورة
│       │   │   └── route.ts  # API لإنشاء فاتورة (POST)
│       │   ├── [invoiceId]/  # تفاصيل فاتورة محددة
│       │   │   ├── page.tsx    # عرض تفاصيل الفاتورة (GET)
│       │   │   ├── print/      # مسار خاص للطباعة (يُعرض الفاتورة بتنسيق الطباعة)
│       │   │   │   └── page.tsx
│       │   │   └── route.ts    # API لفاتورة محددة (GET, PUT, DELETE)
│       │   └── route.ts    # API للفواتير (GET)
│       └── transactions/   # مسار لعمليات مالية أخرى إن وجدت
│           └── ...
└── api/                    # مجلد منفصل لجميع API endpoints (إذا لم تستخدم route.ts مباشرة في المسارات)
    ├── auth/               # APIs للمصادقة (تسجيل الدخول، التسجيل)
    │   └── route.ts
    ├── common/             # APIs للبيانات المشتركة (مثلاً: قائمة الشركات، قائمة طرق الدفع)
    │   └── route.ts
    └── rpc/                # مجلد لـ RPC-style APIs (استدعاء الإجراءات المخزنة)
        ├── sales/
        │   ├── createInvoice.ts # API لاستدعاء sp_CreateSalesInvoice
        └── inventory/
            └── addProduct.ts    # API لاستدعاء sp_AddProduct
```

## خطة التنفيذ

### المرحلة 1: إنشاء الملفات الأساسية

1. ✅ إنشاء ملف `db-schema.ts` لتعريف هيكل قاعدة البيانات
2. ✅ إنشاء ملف `types.ts` لتعريف أنواع البيانات
3. ✅ إنشاء ملف `api-utils.ts` للوظائف المساعدة المشتركة

### المرحلة 2: إنشاء الهيكل الجديد للمجلدات

1. إنشاء المجلدات الجديدة في app/ (على سبيل المثال: sales/, invoices/, customers/, products/, api/rpc/)
2. التأكد من أن أسماء المجلدات والأحرف (كبيرة/صغيرة) متطابقة تمامًا مع الخطة

### المرحلة 3: نقل وتعديل الـ APIs (ملفات route.ts)

1. نقل الـ APIs الموجودة المتعلقة بالمبيعات والفواتير إلى مواقعها الجديدة
2. تعديل الاستيرادات (imports) والمسارات (paths) داخل هذه الملفات
3. تعديل استعلامات SQL داخل الـ APIs لتستخدم التسميات الدقيقة من db-schema.ts
4. تنفيذ RPC APIs لاستدعاء الإجراءات المخزنة

### المرحلة 4: نقل وتعديل صفحات الـ UI (ملفات page.tsx)

1. نقل مكونات الواجهة الأمامية المتعلقة بالفواتير والمبيعات إلى مواقعها الجديدة
2. تعديل الاستيرادات والمسارات
3. تعديل استدعاءات الـ APIs لتتصل بالـ APIs في مواقعها الجديدة

### المرحلة 5: اختبار مكثف

1. اختبار كل مسار جديد وكل API لضمان عمله بشكل صحيح
2. اختبار سيناريوهات إنشاء فاتورة جديدة، عرض الفواتير، طباعة الفواتير
3. اختبار حالات الحافة (Edge Cases)

## القرارات التصميمية

### 1. توحيد invoices و sales تحت sales/

**الفكرة**: sales هو القسم الرئيسي الذي يشمل كل ما يتعلق بالمبيعات. invoices هي جزء لا يتجزأ من عمليات المبيعات.

**التحسين**: بدلاً من مسارين منفصلين، نضع invoices ضمن sales/invoices. هذا يعكس التسلسل الهرمي المنطقي للأعمال.

### 2. المسؤولية الواضحة

- **app/(dashboard)/sales/page.tsx**: نظرة عامة على لوحة تحكم المبيعات، إحصائيات، تقارير.
- **app/(dashboard)/sales/invoices/...**: مسؤولة عن إدارة الفواتير (عرض، إنشاء، تعديل، حذف، طباعة).
- **app/(dashboard)/sales/customers/...**: إدارة العملاء.
- **app/(dashboard)/sales/products/...**: إدارة المنتجات.

### 3. استخدام route.ts بكثافة (API Routes)

في App Router، route.ts هي أفضل طريقة لإنشاء API endpoints مباشرة بجانب المكونات التي تستخدمها.

**مثال**:
- **app/(dashboard)/sales/invoices/route.ts**: يتعامل مع GET (جلب قائمة الفواتير) و POST (إنشاء فاتورة جديدة).
- **app/(dashboard)/sales/invoices/[invoiceId]/route.ts**: يتعامل مع GET (جلب تفاصيل فاتورة معينة), PUT (تحديث فاتورة), DELETE (حذف فاتورة).

**الفائدة**: يقرب منطق الـ API من المكونات التي تستهلكه، مما يسهل تتبع الأخطاء والتطوير.

### 4. استخدام الإجراءات المخزنة عبر RPC-style APIs

**الفكرة**: بعض العمليات ليست مجرد "جلب" أو "تعديل" مورد، بل هي "عمليات" معقدة تنفذ منطق أعمال. الإجراءات المخزنة في SQL Server هي مثال على ذلك.

**التحسين**: إنشاء مجلد api/rpc/ لـ "Remote Procedure Call" APIs.

**مثال**: api/rpc/sales/createInvoice.ts
- هذا الـ API سيحتوي فقط على منطق استدعاء sales.sp_CreateSalesInvoice في قاعدة البيانات.
- الواجهة الأمامية أو صفحة إنشاء الفاتورة ستستدعي هذا الـ API بدلاً من محاولة بناء منطق الإدراج المعقد بنفسها.

**الفائدة**: يقلل من تعقيد الـ API، ويدفع بمنطق الأعمال المعقد إلى قاعدة البيانات حيث يتم تنفيذه بكفاءة وأمان كمعاملة واحدة.

## التحديات المتوقعة

1. **تغيير مسارات API**: قد يؤدي تغيير مسارات API إلى كسر الاستدعاءات الحالية في الواجهة الأمامية.
   - **الحل**: تحديث جميع استدعاءات API في الواجهة الأمامية بشكل متزامن، أو إنشاء مسارات توجيه مؤقتة.

2. **تعقيد نقل الكود**: قد يكون نقل الكود من الهيكل القديم إلى الهيكل الجديد معقدًا.
   - **الحل**: اتباع نهج تدريجي، والتأكد من اختبار كل جزء بعد نقله.

3. **تغيير هيكل البيانات**: قد يتطلب تغيير هيكل البيانات تعديلات في قاعدة البيانات.
   - **الحل**: استخدام ملف `db-schema.ts` كمرجع مركزي لجميع تفاصيل قاعدة البيانات، وتحديثه إذا لزم الأمر.

## الفوائد المتوقعة

1. **تحسين قابلية الصيانة**: هيكل أكثر تنظيمًا وفصل واضح للمسؤوليات.
2. **تقليل التكرار**: استخراج الوظائف المشتركة إلى مكتبات مشتركة.
3. **تحسين الأداء**: استخدام الإجراءات المخزنة للعمليات المعقدة.
4. **تحسين تجربة المطور**: هيكل أكثر وضوحًا وسهولة في الفهم والتطوير.
5. **تحسين قابلية التوسع**: هيكل يسمح بإضافة ميزات جديدة بسهولة.

## ملاحظات إضافية

- يجب الاحتفاظ بنسخة احتياطية من الكود الأصلي قبل بدء التغييرات.
- يجب اختبار كل جزء بعد نقله للتأكد من عمله بشكل صحيح.
- يجب توثيق جميع التغييرات والقرارات التصميمية في هذا الملف.